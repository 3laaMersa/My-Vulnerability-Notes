## How does Caching work?

The whole idea of caching in computer science is about taking a copy of a specific content or page and sending it instead of the server to whatever is trying to access it.

The same idea exists when using CPU and HTTP requests that sas Js files.  PNG and CSS or database caching.

The idea of web caching is that existing software or hardware called **Load Balancer** or proxy server or cache server is a hardware or software located between the original servers of the backend and the users[browsers] that talk to the backend.

![example2.bmp](https://github.com/3laaMersa/Vulnerability-Notes/blob/main/Web%20Cache%20Poisoning/examples/example2.bmp)

Because of this principle, caches tend to sit between the client/user
and the server/component. This is very important to understand, in
order to understand Web Cache Poisoning. In the web’s ecosystem, the
types of caches that are used can vary. Some examples include but are
not limited to:

- Memcached
- Varnish
- CDNs (i.e. Akamai, MaxCDN, AWS)

### **There is a configuration in all caches :**

For example :

- To save any file larger than 10 MB
- To store files with the extension js, png, css
- Every 12 hours, the example.js file is taken from the server
- To store files that are sent more than 1000 times, and so on

![example1.png](https://github.com/3laaMersa/Vulnerability-Notes/blob/main/Web%20Cache%20Poisoning/examples/example1.png)

The idea behind caching is to persistently store “answers” (responses) to frequently requested “questions” (requests) – bypassing the need to recalculate heavy requests. A caching system needs at least two main functions:

1. How long the item will be cached
2. Determine whether or not the request is hitting the cache (hence the fast response) or missing it (hence needing to ask the application)

## Example

Imagine we are a caching system for a simple site that always resides on the same domain **example.com**. In that case, using the endpoint as a key would be great:

### Request

```php
POST https://example.com/stats?page=1 HTTP/1.1
Host: example.com
Accept-Language: en-US
```

### Response

```php
HTTP/1.1 200 OK
<h1>Stats Page 1</h1>
<p>Language: en-US</p>
```

This means we can now cache that response for the next user requesting the path `/stats?page=1:`

### Cache

| Key             | Value        |
| --------------- | ------------ |
| stats?page=1    | Stats Page 1 |
| Language: en-US |

You may notice that the caching system will consider the following two requests to be the same. However the `Accept-Language` headers differ slightly.

### Request 1

```
POST https://example.com/stats?page=1 HTTP/1.1
Host: example.com
Accept-Language: en-US
```

### Request 2

```
POST https://example.com/stats?page=1 HTTP/1.1
Host: example.com
Accept-Language: de
```

This is a problem because:

1. The website will respond in English (US) even if the client requests the content to be in German, resulting in a visual bug.
2. An unkeyed input (**Accept-Language**) is reflected in the page.

So what would happen if we sent a request with a [Cross-site Scripting](https://www.acunetix.com/websitesecurity/cross-site-scripting/) payload instead like so:

```
POST https://example.com/stats?page=1&cachebust=1 HTTP/1.1
Host: example.com
Accept-Language:<script>alert(document.domain)</script>
```

And the cache is updated.

| Key                                                      | Value                 |
| -------------------------------------------------------- | --------------------- |
| stats?page=1&cachebust=1                                 | <h1>Stats Page 1</h1> |
| <p>Language: <script>alert(document.domain)</script></p> |

This means that **any** user that accesses the URL https://example.com/stats?page=1&cachebust=1
will return the cached value. This includes the malicious payload
without the application realizing, thus exploiting the user’s browser.

## Remediating Cache Poisoning attacks

Defending yourself against Cache Poisoning attacks can be quite
tricky. Disabling caching entirely is one such way which is not feasible
for most and understandably so. Some helpful methods however are to:

- Heavily cache static response, such as **.js**, **.css**, **.png** files, blog posts, landing pages or any page that is always identical.
- Make sure you are not vulnerable to Cross-site Scripting attacks so
  that even in the event of such a vulnerability, the user’s browser can’t be exploited.
- Understand and restrict where caching is done. Are you using
  frameworks that implement their own caching? If so you may want to
  disable that and handle caching at a singular point (e.g. CloudFlare).
- Avoid using user inputs (i.e. HTTP Headers) to be used as the cache key.

## Conclusion

Finally, while all of the above can seem very daunting, [web application scanners](https://www.acunetix.com/vulnerability-scanner/web-application-security/) such as Acunetix can detect [Web Cache Poisoning](https://www.acunetix.com/vulnerabilities/web/web-cache-poisoning/) as well as [Cross-site Scripting](https://www.acunetix.com/websitesecurity/cross-site-scripting/) with pinpoint accuracy.

This will **drastically** reduce the time taken to discover such vulnerabilities and thus help you fix them before attackers discover them.
